var data = {lines:[
{"lineNum":"    1","line":"//! The memory module contains the implementation data structures and helper functions used to"},
{"lineNum":"    2","line":"//! manipulate and access wasm memory."},
{"lineNum":"    3","line":"use crate::{"},
{"lineNum":"    4","line":"    error::{CreationError, GrowError},"},
{"lineNum":"    5","line":"    export::Export,"},
{"lineNum":"    6","line":"    import::IsExport,"},
{"lineNum":"    7","line":"    memory::dynamic::DYNAMIC_GUARD_SIZE,"},
{"lineNum":"    8","line":"    memory::static_::{SAFE_STATIC_GUARD_SIZE, SAFE_STATIC_HEAP_SIZE},"},
{"lineNum":"    9","line":"    types::{MemoryDescriptor, ValueType},"},
{"lineNum":"   10","line":"    units::Pages,"},
{"lineNum":"   11","line":"    vm,"},
{"lineNum":"   12","line":"};"},
{"lineNum":"   13","line":"use std::{cell::Cell, fmt, mem, sync::Arc};"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"use std::sync::Mutex as StdMutex;"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"pub use self::dynamic::DynamicMemory;"},
{"lineNum":"   18","line":"pub use self::static_::StaticMemory;"},
{"lineNum":"   19","line":"pub use self::view::{Atomically, MemoryView};"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"use parking_lot::Mutex;"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"mod dynamic;"},
{"lineNum":"   24","line":"pub mod ptr;"},
{"lineNum":"   25","line":"mod static_;"},
{"lineNum":"   26","line":"mod view;"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"#[derive(Clone)]"},
{"lineNum":"   29","line":"enum MemoryVariant {"},
{"lineNum":"   30","line":"    Unshared(UnsharedMemory),"},
{"lineNum":"   31","line":"    Shared(SharedMemory),"},
{"lineNum":"   32","line":"}"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"/// A shared or unshared wasm linear memory."},
{"lineNum":"   35","line":"///"},
{"lineNum":"   36","line":"/// A `Memory` represents the memory used by a wasm instance."},
{"lineNum":"   37","line":"#[derive(Clone)]"},
{"lineNum":"   38","line":"pub struct Memory {"},
{"lineNum":"   39","line":"    desc: MemoryDescriptor,"},
{"lineNum":"   40","line":"    variant: MemoryVariant,"},
{"lineNum":"   41","line":"}"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"impl Memory {"},
{"lineNum":"   44","line":"    /// Create a new `Memory` from a [`MemoryDescriptor`]"},
{"lineNum":"   45","line":"    ///"},
{"lineNum":"   46","line":"    /// [`MemoryDescriptor`]: struct.MemoryDescriptor.html"},
{"lineNum":"   47","line":"    ///"},
{"lineNum":"   48","line":"    /// Usage:"},
{"lineNum":"   49","line":"    ///"},
{"lineNum":"   50","line":"    /// ```"},
{"lineNum":"   51","line":"    /// # use wasmer_runtime_core::types::MemoryDescriptor;"},
{"lineNum":"   52","line":"    /// # use wasmer_runtime_core::memory::Memory;"},
{"lineNum":"   53","line":"    /// # use wasmer_runtime_core::error::Result;"},
{"lineNum":"   54","line":"    /// # use wasmer_runtime_core::units::Pages;"},
{"lineNum":"   55","line":"    /// fn create_memory() -> Result<()> {"},
{"lineNum":"   56","line":"    ///     let descriptor = MemoryDescriptor::new(Pages(10), None, false).unwrap();"},
{"lineNum":"   57","line":"    ///"},
{"lineNum":"   58","line":"    ///     let memory = Memory::new(descriptor)?;"},
{"lineNum":"   59","line":"    ///     Ok(())"},
{"lineNum":"   60","line":"    /// }"},
{"lineNum":"   61","line":"    /// ```"},
{"lineNum":"   62","line":"    pub fn new(desc: MemoryDescriptor) -> Result<Self, CreationError> {"},
{"lineNum":"   63","line":"        if let Some(max) = desc.maximum {"},
{"lineNum":"   64","line":"            if max < desc.minimum {"},
{"lineNum":"   65","line":"                return Err(CreationError::InvalidDescriptor("},
{"lineNum":"   66","line":"                    \"Max number of memory pages is less than the minimum number of pages\""},
{"lineNum":"   67","line":"                        .to_string(),"},
{"lineNum":"   68","line":"                ));"},
{"lineNum":"   69","line":"            }"},
{"lineNum":"   70","line":"        }"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"        if desc.shared && desc.maximum.is_none() {"},
{"lineNum":"   73","line":"            return Err(CreationError::InvalidDescriptor("},
{"lineNum":"   74","line":"                \"Max number of pages is required for shared memory\".to_string(),"},
{"lineNum":"   75","line":"            ));"},
{"lineNum":"   76","line":"        }"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"        let variant = if !desc.shared {"},
{"lineNum":"   79","line":"            MemoryVariant::Unshared(UnsharedMemory::new(desc)?)"},
{"lineNum":"   80","line":"        } else {"},
{"lineNum":"   81","line":"            MemoryVariant::Shared(SharedMemory::new(desc)?)"},
{"lineNum":"   82","line":"        };"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"        Ok(Memory { desc, variant })"},
{"lineNum":"   85","line":"    }"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"    /// Return the [`MemoryDescriptor`] that this memory"},
{"lineNum":"   88","line":"    /// was created with."},
{"lineNum":"   89","line":"    ///"},
{"lineNum":"   90","line":"    /// [`MemoryDescriptor`]: struct.MemoryDescriptor.html"},
{"lineNum":"   91","line":"    pub fn descriptor(&self) -> MemoryDescriptor {"},
{"lineNum":"   92","line":"        self.desc"},
{"lineNum":"   93","line":"    }"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"    /// Grow this memory by the specified number of pages."},
{"lineNum":"   96","line":"    pub fn grow(&self, delta: Pages) -> Result<Pages, GrowError> {"},
{"lineNum":"   97","line":"        match &self.variant {"},
{"lineNum":"   98","line":"            MemoryVariant::Unshared(unshared_mem) => unshared_mem.grow(delta),"},
{"lineNum":"   99","line":"            MemoryVariant::Shared(shared_mem) => shared_mem.grow(delta),"},
{"lineNum":"  100","line":"        }"},
{"lineNum":"  101","line":"    }"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"    /// The size, in wasm pages, of this memory."},
{"lineNum":"  104","line":"    pub fn size(&self) -> Pages {"},
{"lineNum":"  105","line":"        match &self.variant {"},
{"lineNum":"  106","line":"            MemoryVariant::Unshared(unshared_mem) => unshared_mem.size(),"},
{"lineNum":"  107","line":"            MemoryVariant::Shared(shared_mem) => shared_mem.size(),"},
{"lineNum":"  108","line":"        }"},
{"lineNum":"  109","line":"    }"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"    /// Return a \"view\" of the currently accessible memory. By"},
{"lineNum":"  112","line":"    /// default, the view is unsyncronized, using regular memory"},
{"lineNum":"  113","line":"    /// accesses. You can force a memory view to use atomic accesses"},
{"lineNum":"  114","line":"    /// by calling the [`atomically`] method."},
{"lineNum":"  115","line":"    ///"},
{"lineNum":"  116","line":"    /// [`atomically`]: memory/struct.MemoryView.html#method.atomically"},
{"lineNum":"  117","line":"    ///"},
{"lineNum":"  118","line":"    /// # Notes:"},
{"lineNum":"  119","line":"    ///"},
{"lineNum":"  120","line":"    /// This method is safe (as in, it won\'t cause the host to crash or have UB),"},
{"lineNum":"  121","line":"    /// but it doesn\'t obey rust\'s rules involving data races, especially concurrent ones."},
{"lineNum":"  122","line":"    /// Therefore, if this memory is shared between multiple threads, a single memory"},
{"lineNum":"  123","line":"    /// location can be mutated concurrently without synchronization."},
{"lineNum":"  124","line":"    ///"},
{"lineNum":"  125","line":"    /// # Usage:"},
{"lineNum":"  126","line":"    ///"},
{"lineNum":"  127","line":"    /// ```"},
{"lineNum":"  128","line":"    /// # use wasmer_runtime_core::memory::{Memory, MemoryView};"},
{"lineNum":"  129","line":"    /// # use std::{cell::Cell, sync::atomic::Ordering};"},
{"lineNum":"  130","line":"    /// # fn view_memory(memory: Memory) {"},
{"lineNum":"  131","line":"    /// // Without synchronization."},
{"lineNum":"  132","line":"    /// let view: MemoryView<u8> = memory.view();"},
{"lineNum":"  133","line":"    /// for byte in view[0x1000 .. 0x1010].iter().map(Cell::get) {"},
{"lineNum":"  134","line":"    ///     println!(\"byte: {}\", byte);"},
{"lineNum":"  135","line":"    /// }"},
{"lineNum":"  136","line":"    ///"},
{"lineNum":"  137","line":"    /// // With synchronization."},
{"lineNum":"  138","line":"    /// let atomic_view = view.atomically();"},
{"lineNum":"  139","line":"    /// for byte in atomic_view[0x1000 .. 0x1010].iter().map(|atom| atom.load(Ordering::SeqCst)) {"},
{"lineNum":"  140","line":"    ///     println!(\"byte: {}\", byte);"},
{"lineNum":"  141","line":"    /// }"},
{"lineNum":"  142","line":"    /// # }"},
{"lineNum":"  143","line":"    /// ```"},
{"lineNum":"  144","line":"    pub fn view<T: ValueType>(&self) -> MemoryView<T> {"},
{"lineNum":"  145","line":"        let vm::LocalMemory { base, .. } = unsafe { *self.vm_local_memory() };"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"        let length = self.size().bytes().0 / mem::size_of::<T>();"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"        unsafe { MemoryView::new(base as _, length as u32) }"},
{"lineNum":"  150","line":"    }"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"    pub(crate) fn vm_local_memory(&self) -> *mut vm::LocalMemory {"},
{"lineNum":"  153","line":"        match &self.variant {"},
{"lineNum":"  154","line":"            MemoryVariant::Unshared(unshared_mem) => unshared_mem.vm_local_memory(),"},
{"lineNum":"  155","line":"            MemoryVariant::Shared(shared_mem) => shared_mem.vm_local_memory(),"},
{"lineNum":"  156","line":"        }"},
{"lineNum":"  157","line":"    }"},
{"lineNum":"  158","line":"}"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"impl IsExport for Memory {"},
{"lineNum":"  161","line":"    fn to_export(&self) -> Export {"},
{"lineNum":"  162","line":"        Export::Memory(self.clone())"},
{"lineNum":"  163","line":"    }"},
{"lineNum":"  164","line":"}"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"impl fmt::Debug for Memory {"},
{"lineNum":"  167","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  168","line":"        f.debug_struct(\"Memory\")"},
{"lineNum":"  169","line":"            .field(\"desc\", &self.desc)"},
{"lineNum":"  170","line":"            .field(\"size\", &self.size())"},
{"lineNum":"  171","line":"            .finish()"},
{"lineNum":"  172","line":"    }"},
{"lineNum":"  173","line":"}"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"/// A kind a memory."},
{"lineNum":"  176","line":"#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq, Hash)]","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  177","line":"pub enum MemoryType {"},
{"lineNum":"  178","line":"    /// A dynamic memory."},
{"lineNum":"  179","line":"    Dynamic,"},
{"lineNum":"  180","line":"    /// A static memory."},
{"lineNum":"  181","line":"    Static,"},
{"lineNum":"  182","line":"    /// A shared static memory."},
{"lineNum":"  183","line":"    SharedStatic,"},
{"lineNum":"  184","line":"}"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"impl MemoryType {"},
{"lineNum":"  187","line":"    #[doc(hidden)]"},
{"lineNum":"  188","line":"    pub fn guard_size(self) -> u64 {"},
{"lineNum":"  189","line":"        match self {"},
{"lineNum":"  190","line":"            MemoryType::Dynamic => DYNAMIC_GUARD_SIZE as u64,"},
{"lineNum":"  191","line":"            MemoryType::Static | MemoryType::SharedStatic => SAFE_STATIC_GUARD_SIZE as u64,"},
{"lineNum":"  192","line":"        }"},
{"lineNum":"  193","line":"    }"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"    #[doc(hidden)]"},
{"lineNum":"  196","line":"    pub fn bounds(self) -> Option<u64> {"},
{"lineNum":"  197","line":"        match self {"},
{"lineNum":"  198","line":"            MemoryType::Dynamic => None,"},
{"lineNum":"  199","line":"            MemoryType::Static | MemoryType::SharedStatic => Some(SAFE_STATIC_HEAP_SIZE as u64),"},
{"lineNum":"  200","line":"        }"},
{"lineNum":"  201","line":"    }"},
{"lineNum":"  202","line":"}"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"enum UnsharedMemoryStorage {"},
{"lineNum":"  205","line":"    Dynamic(Box<DynamicMemory>),"},
{"lineNum":"  206","line":"    Static(Box<StaticMemory>),"},
{"lineNum":"  207","line":"}"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"/// A reference to an unshared memory."},
{"lineNum":"  210","line":"pub struct UnsharedMemory {"},
{"lineNum":"  211","line":"    internal: Arc<UnsharedMemoryInternal>,"},
{"lineNum":"  212","line":"}"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"struct UnsharedMemoryInternal {"},
{"lineNum":"  215","line":"    storage: StdMutex<UnsharedMemoryStorage>,"},
{"lineNum":"  216","line":"    local: Cell<vm::LocalMemory>,"},
{"lineNum":"  217","line":"}"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"// Manually implemented because UnsharedMemoryInternal uses `Cell` and is used in an Arc;"},
{"lineNum":"  220","line":"// this is safe because the lock for storage can be used to protect (seems like a weak reason: PLEASE REVIEW!)"},
{"lineNum":"  221","line":"unsafe impl Sync for UnsharedMemoryInternal {}"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"impl UnsharedMemory {"},
{"lineNum":"  224","line":"    /// Create a new `UnsharedMemory` from the given memory descriptor."},
{"lineNum":"  225","line":"    pub fn new(desc: MemoryDescriptor) -> Result<Self, CreationError> {"},
{"lineNum":"  226","line":"        let mut local = vm::LocalMemory {"},
{"lineNum":"  227","line":"            base: std::ptr::null_mut(),"},
{"lineNum":"  228","line":"            bound: 0,"},
{"lineNum":"  229","line":"            memory: std::ptr::null_mut(),"},
{"lineNum":"  230","line":"        };"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"        let storage = match desc.memory_type() {"},
{"lineNum":"  233","line":"            MemoryType::Dynamic => {"},
{"lineNum":"  234","line":"                UnsharedMemoryStorage::Dynamic(DynamicMemory::new(desc, &mut local)?)"},
{"lineNum":"  235","line":"            }"},
{"lineNum":"  236","line":"            MemoryType::Static => {"},
{"lineNum":"  237","line":"                UnsharedMemoryStorage::Static(StaticMemory::new(desc, &mut local)?)"},
{"lineNum":"  238","line":"            }"},
{"lineNum":"  239","line":"            MemoryType::SharedStatic => {"},
{"lineNum":"  240","line":"                return Err(CreationError::InvalidDescriptor("},
{"lineNum":"  241","line":"                    \"attempting to create shared unshared memory\".to_string(),"},
{"lineNum":"  242","line":"                ));"},
{"lineNum":"  243","line":"            }"},
{"lineNum":"  244","line":"        };"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"        Ok(Self {"},
{"lineNum":"  247","line":"            internal: Arc::new(UnsharedMemoryInternal {"},
{"lineNum":"  248","line":"                storage: StdMutex::new(storage),"},
{"lineNum":"  249","line":"                local: Cell::new(local),"},
{"lineNum":"  250","line":"            }),"},
{"lineNum":"  251","line":"        })"},
{"lineNum":"  252","line":"    }"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"    /// Try to grow this memory by the given number of delta pages."},
{"lineNum":"  255","line":"    pub fn grow(&self, delta: Pages) -> Result<Pages, GrowError> {"},
{"lineNum":"  256","line":"        let mut storage = self.internal.storage.lock().unwrap();"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"        let mut local = self.internal.local.get();"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"        let pages = match &mut *storage {"},
{"lineNum":"  261","line":"            UnsharedMemoryStorage::Dynamic(dynamic_memory) => {"},
{"lineNum":"  262","line":"                dynamic_memory.grow(delta, &mut local)"},
{"lineNum":"  263","line":"            }"},
{"lineNum":"  264","line":"            UnsharedMemoryStorage::Static(static_memory) => static_memory.grow(delta, &mut local),"},
{"lineNum":"  265","line":"        };"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"        self.internal.local.set(local);"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"        pages"},
{"lineNum":"  270","line":"    }"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"    /// Size of this memory in pages."},
{"lineNum":"  273","line":"    pub fn size(&self) -> Pages {"},
{"lineNum":"  274","line":"        let storage = self.internal.storage.lock().unwrap();"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"        match &*storage {"},
{"lineNum":"  277","line":"            UnsharedMemoryStorage::Dynamic(ref dynamic_memory) => dynamic_memory.size(),"},
{"lineNum":"  278","line":"            UnsharedMemoryStorage::Static(ref static_memory) => static_memory.size(),"},
{"lineNum":"  279","line":"        }"},
{"lineNum":"  280","line":"    }"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"    pub(crate) fn vm_local_memory(&self) -> *mut vm::LocalMemory {"},
{"lineNum":"  283","line":"        self.internal.local.as_ptr()"},
{"lineNum":"  284","line":"    }"},
{"lineNum":"  285","line":"}"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"impl Clone for UnsharedMemory {"},
{"lineNum":"  288","line":"    fn clone(&self) -> Self {"},
{"lineNum":"  289","line":"        UnsharedMemory {"},
{"lineNum":"  290","line":"            internal: Arc::clone(&self.internal),"},
{"lineNum":"  291","line":"        }"},
{"lineNum":"  292","line":"    }"},
{"lineNum":"  293","line":"}"},
{"lineNum":"  294","line":""},
{"lineNum":"  295","line":"/// A reference to a shared memory."},
{"lineNum":"  296","line":"pub struct SharedMemory {"},
{"lineNum":"  297","line":"    internal: Arc<SharedMemoryInternal>,"},
{"lineNum":"  298","line":"}"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"/// Data structure for a shared internal memory."},
{"lineNum":"  301","line":"pub struct SharedMemoryInternal {"},
{"lineNum":"  302","line":"    memory: StdMutex<Box<StaticMemory>>,"},
{"lineNum":"  303","line":"    local: Cell<vm::LocalMemory>,"},
{"lineNum":"  304","line":"    lock: Mutex<()>,"},
{"lineNum":"  305","line":"}"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"// Manually implemented because SharedMemoryInternal uses `Cell` and is used in Arc;"},
{"lineNum":"  308","line":"// this is safe because of `lock`; accesing `local` without locking `lock` is not safe (Maybe we could put the lock on Local then?)"},
{"lineNum":"  309","line":"unsafe impl Sync for SharedMemoryInternal {}"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"impl SharedMemory {"},
{"lineNum":"  312","line":"    fn new(desc: MemoryDescriptor) -> Result<Self, CreationError> {"},
{"lineNum":"  313","line":"        let mut local = vm::LocalMemory {"},
{"lineNum":"  314","line":"            base: std::ptr::null_mut(),"},
{"lineNum":"  315","line":"            bound: 0,"},
{"lineNum":"  316","line":"            memory: std::ptr::null_mut(),"},
{"lineNum":"  317","line":"        };"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"        let memory = StaticMemory::new(desc, &mut local)?;"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"        Ok(Self {"},
{"lineNum":"  322","line":"            internal: Arc::new(SharedMemoryInternal {"},
{"lineNum":"  323","line":"                memory: StdMutex::new(memory),"},
{"lineNum":"  324","line":"                local: Cell::new(local),"},
{"lineNum":"  325","line":"                lock: Mutex::new(()),"},
{"lineNum":"  326","line":"            }),"},
{"lineNum":"  327","line":"        })"},
{"lineNum":"  328","line":"    }"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"    /// Try to grow this memory by the given number of delta pages."},
{"lineNum":"  331","line":"    pub fn grow(&self, delta: Pages) -> Result<Pages, GrowError> {"},
{"lineNum":"  332","line":"        let _guard = self.internal.lock.lock();"},
{"lineNum":"  333","line":"        let mut local = self.internal.local.get();"},
{"lineNum":"  334","line":"        let mut memory = self.internal.memory.lock().unwrap();"},
{"lineNum":"  335","line":"        let pages = memory.grow(delta, &mut local);"},
{"lineNum":"  336","line":"        pages"},
{"lineNum":"  337","line":"    }"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"    /// Size of this memory in pages."},
{"lineNum":"  340","line":"    pub fn size(&self) -> Pages {"},
{"lineNum":"  341","line":"        let _guard = self.internal.lock.lock();"},
{"lineNum":"  342","line":"        let memory = self.internal.memory.lock().unwrap();"},
{"lineNum":"  343","line":"        memory.size()"},
{"lineNum":"  344","line":"    }"},
{"lineNum":"  345","line":""},
{"lineNum":"  346","line":"    /// Gets a mutable pointer to the `LocalMemory`."},
{"lineNum":"  347","line":"    // This function is scary, because the mutex is not locked here"},
{"lineNum":"  348","line":"    pub(crate) fn vm_local_memory(&self) -> *mut vm::LocalMemory {"},
{"lineNum":"  349","line":"        self.internal.local.as_ptr()"},
{"lineNum":"  350","line":"    }"},
{"lineNum":"  351","line":"}"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"impl Clone for SharedMemory {"},
{"lineNum":"  354","line":"    fn clone(&self) -> Self {"},
{"lineNum":"  355","line":"        SharedMemory {"},
{"lineNum":"  356","line":"            internal: Arc::clone(&self.internal),"},
{"lineNum":"  357","line":"        }"},
{"lineNum":"  358","line":"    }"},
{"lineNum":"  359","line":"}"},
{"lineNum":"  360","line":""},
{"lineNum":"  361","line":"#[cfg(test)]"},
{"lineNum":"  362","line":"mod memory_tests {"},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"    use super::{Memory, MemoryDescriptor, Pages};"},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"    #[test]"},
{"lineNum":"  367","line":"    fn test_initial_memory_size() {"},
{"lineNum":"  368","line":"        let memory_desc = MemoryDescriptor::new(Pages(10), Some(Pages(20)), false).unwrap();"},
{"lineNum":"  369","line":"        let unshared_memory = Memory::new(memory_desc).unwrap();"},
{"lineNum":"  370","line":"        assert_eq!(unshared_memory.size(), Pages(10));"},
{"lineNum":"  371","line":"    }"},
{"lineNum":"  372","line":""},
{"lineNum":"  373","line":"    #[test]"},
{"lineNum":"  374","line":"    fn test_invalid_descriptor_returns_error() {"},
{"lineNum":"  375","line":"        let memory_desc = MemoryDescriptor::new(Pages(10), None, true);"},
{"lineNum":"  376","line":"        assert!("},
{"lineNum":"  377","line":"            memory_desc.is_err(),"},
{"lineNum":"  378","line":"            \"Max number of pages is required for shared memory\""},
{"lineNum":"  379","line":"        )"},
{"lineNum":"  380","line":"    }"},
{"lineNum":"  381","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "compile_debug", "date" : "2019-11-28 11:37:30", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
