var data = {lines:[
{"lineNum":"    1","line":"use crate::error::GrowError;"},
{"lineNum":"    2","line":"use crate::{"},
{"lineNum":"    3","line":"    error::CreationError,"},
{"lineNum":"    4","line":"    sys,"},
{"lineNum":"    5","line":"    types::MemoryDescriptor,"},
{"lineNum":"    6","line":"    units::{Bytes, Pages},"},
{"lineNum":"    7","line":"    vm,"},
{"lineNum":"    8","line":"};"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"pub const DYNAMIC_GUARD_SIZE: usize = 4096;"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"/// This is an internal-only api."},
{"lineNum":"   13","line":"///"},
{"lineNum":"   14","line":"/// A Dynamic memory allocates only the minimum amount of memory"},
{"lineNum":"   15","line":"/// when first created. Over time, as it grows, it may reallocate to"},
{"lineNum":"   16","line":"/// a different location and size."},
{"lineNum":"   17","line":"///"},
{"lineNum":"   18","line":"/// Dynamic memories are significantly faster to create than static"},
{"lineNum":"   19","line":"/// memories and use much less virtual memory, however, they require"},
{"lineNum":"   20","line":"/// the WebAssembly module to bounds-check memory accesses."},
{"lineNum":"   21","line":"///"},
{"lineNum":"   22","line":"/// While, a dynamic memory could use a vector of some sort as its"},
{"lineNum":"   23","line":"/// backing memory, we use mmap (or the platform-equivalent) to allow"},
{"lineNum":"   24","line":"/// us to add a guard-page at the end to help elide some bounds-checks."},
{"lineNum":"   25","line":"pub struct DynamicMemory {"},
{"lineNum":"   26","line":"    memory: sys::Memory,"},
{"lineNum":"   27","line":"    current: Pages,"},
{"lineNum":"   28","line":"    max: Option<Pages>,"},
{"lineNum":"   29","line":"}"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"impl DynamicMemory {"},
{"lineNum":"   32","line":"    pub(super) fn new("},
{"lineNum":"   33","line":"        desc: MemoryDescriptor,"},
{"lineNum":"   34","line":"        local: &mut vm::LocalMemory,"},
{"lineNum":"   35","line":"    ) -> Result<Box<Self>, CreationError> {"},
{"lineNum":"   36","line":"        let min_bytes: Bytes = desc.minimum.into();"},
{"lineNum":"   37","line":"        let memory = {"},
{"lineNum":"   38","line":"            let mut memory = sys::Memory::with_size(min_bytes.0 + DYNAMIC_GUARD_SIZE)"},
{"lineNum":"   39","line":"                .map_err(|_| CreationError::UnableToCreateMemory)?;"},
{"lineNum":"   40","line":"            if desc.minimum != Pages(0) {"},
{"lineNum":"   41","line":"                unsafe {"},
{"lineNum":"   42","line":"                    memory"},
{"lineNum":"   43","line":"                        .protect(0..min_bytes.0, sys::Protect::ReadWrite)"},
{"lineNum":"   44","line":"                        .map_err(|_| CreationError::UnableToCreateMemory)?;"},
{"lineNum":"   45","line":"                }"},
{"lineNum":"   46","line":"            }"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"            memory"},
{"lineNum":"   49","line":"        };"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"        let mut storage = Box::new(DynamicMemory {"},
{"lineNum":"   52","line":"            memory,"},
{"lineNum":"   53","line":"            current: desc.minimum,"},
{"lineNum":"   54","line":"            max: desc.maximum,"},
{"lineNum":"   55","line":"        });"},
{"lineNum":"   56","line":"        let storage_ptr: *mut DynamicMemory = &mut *storage;"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"        local.base = storage.memory.as_ptr();"},
{"lineNum":"   59","line":"        local.bound = min_bytes.0;"},
{"lineNum":"   60","line":"        local.memory = storage_ptr as *mut ();"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"        Ok(storage)"},
{"lineNum":"   63","line":"    }"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"    /// The size of this memory in `Pages`."},
{"lineNum":"   66","line":"    pub fn size(&self) -> Pages {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   67","line":"        self.current","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   68","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"    /// Try to grow self by the given number of delta pages."},
{"lineNum":"   71","line":"    pub fn grow(&mut self, delta: Pages, local: &mut vm::LocalMemory) -> Result<Pages, GrowError> {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   72","line":"        if delta == Pages(0) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   73","line":"            return Ok(self.current);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   74","line":"        }"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"        let new_pages = self.current.checked_add(delta).map_err(|e| e.into())?;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"        if let Some(max) = self.max {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   79","line":"            if new_pages > max {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   80","line":"                return Err(GrowError::ExceededMaxPagesForMemory(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   81","line":"                    new_pages.0 as usize,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   82","line":"                    max.0 as usize,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   83","line":"                ));"},
{"lineNum":"   84","line":"            }"},
{"lineNum":"   85","line":"        }"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"        let mut new_memory = sys::Memory::with_size(new_pages.bytes().0 + DYNAMIC_GUARD_SIZE)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   88","line":"            .map_err(|e| e.into())?;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"        unsafe {"},
{"lineNum":"   91","line":"            new_memory","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   92","line":"                .protect(0..new_pages.bytes().0, sys::Protect::ReadWrite)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   93","line":"                .map_err(|e| e.into())?;","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"            new_memory.as_slice_mut()[..self.current.bytes().0]","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   96","line":"                .copy_from_slice(&self.memory.as_slice()[..self.current.bytes().0]);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   97","line":"        }"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"        self.memory = new_memory; //The old memory gets dropped.","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"        local.base = self.memory.as_ptr();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  102","line":"        local.bound = new_pages.bytes().0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"        let old_pages = self.current;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  105","line":"        self.current = new_pages;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  106","line":"        Ok(old_pages)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  107","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    /// Get this memory represented as a slice of bytes."},
{"lineNum":"  110","line":"    pub fn as_slice(&self) -> &[u8] {"},
{"lineNum":"  111","line":"        unsafe { &self.memory.as_slice()[0..self.current.bytes().0] }"},
{"lineNum":"  112","line":"    }"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"    /// Get this memory represented as a mutable slice of bytes"},
{"lineNum":"  115","line":"    pub fn as_slice_mut(&mut self) -> &mut [u8] {"},
{"lineNum":"  116","line":"        unsafe { &mut self.memory.as_slice_mut()[0..self.current.bytes().0] }"},
{"lineNum":"  117","line":"    }"},
{"lineNum":"  118","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "compile_debug", "date" : "2019-11-28 11:37:30", "instrumented" : 26, "covered" : 0,};
var merged_data = [];
