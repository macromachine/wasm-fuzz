var data = {lines:[
{"lineNum":"    1","line":"//! The cache module provides the common data structures used by compiler backends to allow"},
{"lineNum":"    2","line":"//! serializing compiled wasm code to a binary format.  The binary format can be persisted,"},
{"lineNum":"    3","line":"//! and loaded to allow skipping compilation and fast startup."},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"use crate::{"},
{"lineNum":"    6","line":"    backend::Backend,"},
{"lineNum":"    7","line":"    module::{Module, ModuleInfo},"},
{"lineNum":"    8","line":"    sys::Memory,"},
{"lineNum":"    9","line":"};"},
{"lineNum":"   10","line":"use blake2b_simd::blake2bp;"},
{"lineNum":"   11","line":"use std::{fmt, io, mem, slice};"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"/// Indicates the invalid type of invalid cache file"},
{"lineNum":"   14","line":"#[derive(Debug)]"},
{"lineNum":"   15","line":"pub enum InvalidFileType {"},
{"lineNum":"   16","line":"    /// Given cache header slice does not match the expected size of an `ArtifactHeader`"},
{"lineNum":"   17","line":"    InvalidSize,"},
{"lineNum":"   18","line":"    /// Given cache header slice does not contain the expected magic bytes"},
{"lineNum":"   19","line":"    InvalidMagic,"},
{"lineNum":"   20","line":"}"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"/// Kinds of caching errors"},
{"lineNum":"   23","line":"#[derive(Debug)]"},
{"lineNum":"   24","line":"pub enum Error {"},
{"lineNum":"   25","line":"    /// An IO error while reading/writing a cache binary."},
{"lineNum":"   26","line":"    IoError(io::Error),"},
{"lineNum":"   27","line":"    /// An error deserializing bytes into a cache data structure."},
{"lineNum":"   28","line":"    DeserializeError(String),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   29","line":"    /// An error serializing bytes from a cache data structure."},
{"lineNum":"   30","line":"    SerializeError(String),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   31","line":"    /// An undefined caching error with a message."},
{"lineNum":"   32","line":"    Unknown(String),"},
{"lineNum":"   33","line":"    /// An invalid cache binary given."},
{"lineNum":"   34","line":"    InvalidFile(InvalidFileType),"},
{"lineNum":"   35","line":"    /// The cached binary has been invalidated."},
{"lineNum":"   36","line":"    InvalidatedCache,"},
{"lineNum":"   37","line":"    /// The current backend does not support caching."},
{"lineNum":"   38","line":"    UnsupportedBackend(Backend),"},
{"lineNum":"   39","line":"}"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"impl From<io::Error> for Error {"},
{"lineNum":"   42","line":"    fn from(io_err: io::Error) -> Self {"},
{"lineNum":"   43","line":"        Error::IoError(io_err)"},
{"lineNum":"   44","line":"    }"},
{"lineNum":"   45","line":"}"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"/// The hash of a wasm module."},
{"lineNum":"   48","line":"///"},
{"lineNum":"   49","line":"/// Used as a key when loading and storing modules in a [`Cache`]."},
{"lineNum":"   50","line":"///"},
{"lineNum":"   51","line":"/// [`Cache`]: trait.Cache.html"},
{"lineNum":"   52","line":"#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]"},
{"lineNum":"   53","line":"// WasmHash is made up of two 32 byte arrays instead of a 64 byte array"},
{"lineNum":"   54","line":"// because derive only works on fixed sized arrays size 32 or below"},
{"lineNum":"   55","line":"// TODO: fix this when this gets fixed by improved const generics"},
{"lineNum":"   56","line":"pub struct WasmHash([u8; 32], [u8; 32]);"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"impl WasmHash {"},
{"lineNum":"   59","line":"    /// Hash a wasm module."},
{"lineNum":"   60","line":"    ///"},
{"lineNum":"   61","line":"    /// # Note:"},
{"lineNum":"   62","line":"    /// This does no verification that the supplied data"},
{"lineNum":"   63","line":"    /// is, in fact, a wasm module."},
{"lineNum":"   64","line":"    pub fn generate(wasm: &[u8]) -> Self {"},
{"lineNum":"   65","line":"        let mut first_part = [0u8; 32];"},
{"lineNum":"   66","line":"        let mut second_part = [0u8; 32];"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"        let mut state = blake2bp::State::new();"},
{"lineNum":"   69","line":"        state.update(wasm);"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"        let hasher = state.finalize();"},
{"lineNum":"   72","line":"        let generic_array = hasher.as_bytes();"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"        first_part.copy_from_slice(&generic_array[0..32]);"},
{"lineNum":"   75","line":"        second_part.copy_from_slice(&generic_array[32..64]);"},
{"lineNum":"   76","line":"        WasmHash(first_part, second_part)"},
{"lineNum":"   77","line":"    }"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"    /// Create the hexadecimal representation of the"},
{"lineNum":"   80","line":"    /// stored hash."},
{"lineNum":"   81","line":"    pub fn encode(self) -> String {"},
{"lineNum":"   82","line":"        hex::encode(&self.into_array() as &[u8])"},
{"lineNum":"   83","line":"    }"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"    /// Create hash from hexadecimal representation"},
{"lineNum":"   86","line":"    pub fn decode(hex_str: &str) -> Result<Self, Error> {"},
{"lineNum":"   87","line":"        let bytes = hex::decode(hex_str).map_err(|e| {"},
{"lineNum":"   88","line":"            Error::DeserializeError(format!("},
{"lineNum":"   89","line":"                \"Could not decode prehashed key as hexadecimal: {}\","},
{"lineNum":"   90","line":"                e"},
{"lineNum":"   91","line":"            ))"},
{"lineNum":"   92","line":"        })?;"},
{"lineNum":"   93","line":"        if bytes.len() != 64 {"},
{"lineNum":"   94","line":"            return Err(Error::DeserializeError("},
{"lineNum":"   95","line":"                \"Prehashed keys must deserialze into exactly 64 bytes\".to_string(),"},
{"lineNum":"   96","line":"            ));"},
{"lineNum":"   97","line":"        }"},
{"lineNum":"   98","line":"        use std::convert::TryInto;"},
{"lineNum":"   99","line":"        Ok(WasmHash("},
{"lineNum":"  100","line":"            bytes[0..32].try_into().map_err(|e| {"},
{"lineNum":"  101","line":"                Error::DeserializeError(format!(\"Could not get first 32 bytes: {}\", e))"},
{"lineNum":"  102","line":"            })?,"},
{"lineNum":"  103","line":"            bytes[32..64].try_into().map_err(|e| {"},
{"lineNum":"  104","line":"                Error::DeserializeError(format!(\"Could not get last 32 bytes: {}\", e))"},
{"lineNum":"  105","line":"            })?,"},
{"lineNum":"  106","line":"        ))"},
{"lineNum":"  107","line":"    }"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    pub(crate) fn into_array(self) -> [u8; 64] {"},
{"lineNum":"  110","line":"        let mut total = [0u8; 64];"},
{"lineNum":"  111","line":"        total[0..32].copy_from_slice(&self.0);"},
{"lineNum":"  112","line":"        total[32..64].copy_from_slice(&self.1);"},
{"lineNum":"  113","line":"        total"},
{"lineNum":"  114","line":"    }"},
{"lineNum":"  115","line":"}"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"const CURRENT_CACHE_VERSION: u64 = 0;"},
{"lineNum":"  118","line":"static WASMER_CACHE_MAGIC: [u8; 8] = *b\"WASMER\\0\\0\";"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"/// The header of a cache file."},
{"lineNum":"  121","line":"#[repr(C, packed)]"},
{"lineNum":"  122","line":"struct ArtifactHeader {"},
{"lineNum":"  123","line":"    magic: [u8; 8], // [W, A, S, M, E, R, \\0, \\0]"},
{"lineNum":"  124","line":"    version: u64,"},
{"lineNum":"  125","line":"    data_len: u64,"},
{"lineNum":"  126","line":"}"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"impl ArtifactHeader {"},
{"lineNum":"  129","line":"    pub fn read_from_slice(buffer: &[u8]) -> Result<(&Self, &[u8]), Error> {"},
{"lineNum":"  130","line":"        if buffer.len() >= mem::size_of::<ArtifactHeader>() {"},
{"lineNum":"  131","line":"            if &buffer[..8] == &WASMER_CACHE_MAGIC {"},
{"lineNum":"  132","line":"                let (header_slice, body_slice) = buffer.split_at(mem::size_of::<ArtifactHeader>());"},
{"lineNum":"  133","line":"                let header = unsafe { &*(header_slice.as_ptr() as *const ArtifactHeader) };"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"                if header.version == CURRENT_CACHE_VERSION {"},
{"lineNum":"  136","line":"                    Ok((header, body_slice))"},
{"lineNum":"  137","line":"                } else {"},
{"lineNum":"  138","line":"                    Err(Error::InvalidatedCache)"},
{"lineNum":"  139","line":"                }"},
{"lineNum":"  140","line":"            } else {"},
{"lineNum":"  141","line":"                Err(Error::InvalidFile(InvalidFileType::InvalidMagic))"},
{"lineNum":"  142","line":"            }"},
{"lineNum":"  143","line":"        } else {"},
{"lineNum":"  144","line":"            Err(Error::InvalidFile(InvalidFileType::InvalidSize))"},
{"lineNum":"  145","line":"        }"},
{"lineNum":"  146","line":"    }"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"    pub fn read_from_slice_mut(buffer: &mut [u8]) -> Result<(&mut Self, &mut [u8]), Error> {"},
{"lineNum":"  149","line":"        if buffer.len() >= mem::size_of::<ArtifactHeader>() {"},
{"lineNum":"  150","line":"            if &buffer[..8] == &WASMER_CACHE_MAGIC {"},
{"lineNum":"  151","line":"                let (header_slice, body_slice) ="},
{"lineNum":"  152","line":"                    buffer.split_at_mut(mem::size_of::<ArtifactHeader>());"},
{"lineNum":"  153","line":"                let header = unsafe { &mut *(header_slice.as_ptr() as *mut ArtifactHeader) };"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"                if header.version == CURRENT_CACHE_VERSION {"},
{"lineNum":"  156","line":"                    Ok((header, body_slice))"},
{"lineNum":"  157","line":"                } else {"},
{"lineNum":"  158","line":"                    Err(Error::InvalidatedCache)"},
{"lineNum":"  159","line":"                }"},
{"lineNum":"  160","line":"            } else {"},
{"lineNum":"  161","line":"                Err(Error::InvalidFile(InvalidFileType::InvalidMagic))"},
{"lineNum":"  162","line":"            }"},
{"lineNum":"  163","line":"        } else {"},
{"lineNum":"  164","line":"            Err(Error::InvalidFile(InvalidFileType::InvalidSize))"},
{"lineNum":"  165","line":"        }"},
{"lineNum":"  166","line":"    }"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"    pub fn as_slice(&self) -> &[u8] {"},
{"lineNum":"  169","line":"        let ptr = self as *const ArtifactHeader as *const u8;"},
{"lineNum":"  170","line":"        unsafe { slice::from_raw_parts(ptr, mem::size_of::<ArtifactHeader>()) }"},
{"lineNum":"  171","line":"    }"},
{"lineNum":"  172","line":"}"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"#[derive(Serialize, Deserialize)]"},
{"lineNum":"  175","line":"struct ArtifactInner {"},
{"lineNum":"  176","line":"    info: Box<ModuleInfo>,"},
{"lineNum":"  177","line":"    #[serde(with = \"serde_bytes\")]"},
{"lineNum":"  178","line":"    backend_metadata: Box<[u8]>,"},
{"lineNum":"  179","line":"    compiled_code: Memory,"},
{"lineNum":"  180","line":"}"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"/// Artifact are produced by caching, are serialized/deserialized to binaries, and contain"},
{"lineNum":"  183","line":"/// module info, backend metadata, and compiled code."},
{"lineNum":"  184","line":"pub struct Artifact {"},
{"lineNum":"  185","line":"    inner: ArtifactInner,"},
{"lineNum":"  186","line":"}"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"impl Artifact {"},
{"lineNum":"  189","line":"    pub(crate) fn from_parts("},
{"lineNum":"  190","line":"        info: Box<ModuleInfo>,"},
{"lineNum":"  191","line":"        backend_metadata: Box<[u8]>,"},
{"lineNum":"  192","line":"        compiled_code: Memory,"},
{"lineNum":"  193","line":"    ) -> Self {"},
{"lineNum":"  194","line":"        Self {"},
{"lineNum":"  195","line":"            inner: ArtifactInner {"},
{"lineNum":"  196","line":"                info,"},
{"lineNum":"  197","line":"                backend_metadata,"},
{"lineNum":"  198","line":"                compiled_code,"},
{"lineNum":"  199","line":"            },"},
{"lineNum":"  200","line":"        }"},
{"lineNum":"  201","line":"    }"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"    /// Deserializes an `Artifact` from the given byte slice."},
{"lineNum":"  204","line":"    pub fn deserialize(bytes: &[u8]) -> Result<Self, Error> {"},
{"lineNum":"  205","line":"        let (_, body_slice) = ArtifactHeader::read_from_slice(bytes)?;"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"        let inner = serde_bench::deserialize(body_slice)"},
{"lineNum":"  208","line":"            .map_err(|e| Error::DeserializeError(format!(\"{:#?}\", e)))?;"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"        Ok(Artifact { inner })"},
{"lineNum":"  211","line":"    }"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    /// A reference to the `Artifact`\'s stored `ModuleInfo`"},
{"lineNum":"  214","line":"    pub fn info(&self) -> &ModuleInfo {"},
{"lineNum":"  215","line":"        &self.inner.info"},
{"lineNum":"  216","line":"    }"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"    #[doc(hidden)]"},
{"lineNum":"  219","line":"    pub fn consume(self) -> (ModuleInfo, Box<[u8]>, Memory) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  220","line":"        (","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  221","line":"            *self.inner.info,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  222","line":"            self.inner.backend_metadata,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  223","line":"            self.inner.compiled_code,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  224","line":"        )"},
{"lineNum":"  225","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"    /// Serializes the `Artifact` into a vector of bytes"},
{"lineNum":"  228","line":"    pub fn serialize(&self) -> Result<Vec<u8>, Error> {"},
{"lineNum":"  229","line":"        let cache_header = ArtifactHeader {"},
{"lineNum":"  230","line":"            magic: WASMER_CACHE_MAGIC,"},
{"lineNum":"  231","line":"            version: CURRENT_CACHE_VERSION,"},
{"lineNum":"  232","line":"            data_len: 0,"},
{"lineNum":"  233","line":"        };"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"        let mut buffer = cache_header.as_slice().to_vec();"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"        serde_bench::serialize(&mut buffer, &self.inner)"},
{"lineNum":"  238","line":"            .map_err(|e| Error::SerializeError(e.to_string()))?;"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"        let data_len = (buffer.len() - mem::size_of::<ArtifactHeader>()) as u64;"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"        let (header, _) = ArtifactHeader::read_from_slice_mut(&mut buffer)?;"},
{"lineNum":"  243","line":"        header.data_len = data_len;"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"        Ok(buffer)"},
{"lineNum":"  246","line":"    }"},
{"lineNum":"  247","line":"}"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"/// A generic cache for storing and loading compiled wasm modules."},
{"lineNum":"  250","line":"///"},
{"lineNum":"  251","line":"/// The `wasmer-runtime` supplies a naive `FileSystemCache` api."},
{"lineNum":"  252","line":"pub trait Cache {"},
{"lineNum":"  253","line":"    /// Error type to return when load error occurs"},
{"lineNum":"  254","line":"    type LoadError: fmt::Debug;"},
{"lineNum":"  255","line":"    /// Error type to return when store error occurs"},
{"lineNum":"  256","line":"    type StoreError: fmt::Debug;"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"    /// loads a module using the default `Backend`"},
{"lineNum":"  259","line":"    fn load(&self, key: WasmHash) -> Result<Module, Self::LoadError>;"},
{"lineNum":"  260","line":"    /// loads a cached module using a specific `Backend`"},
{"lineNum":"  261","line":"    fn load_with_backend(&self, key: WasmHash, backend: Backend)"},
{"lineNum":"  262","line":"        -> Result<Module, Self::LoadError>;"},
{"lineNum":"  263","line":"    /// Store a module into the cache with the given key"},
{"lineNum":"  264","line":"    fn store(&mut self, key: WasmHash, module: Module) -> Result<(), Self::StoreError>;"},
{"lineNum":"  265","line":"}"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"/// A unique ID generated from the version of Wasmer for use with cache versioning"},
{"lineNum":"  268","line":"pub const WASMER_VERSION_HASH: &\'static str ="},
{"lineNum":"  269","line":"    include_str!(concat!(env!(\"OUT_DIR\"), \"/wasmer_version_hash.txt\"));"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "compile_debug", "date" : "2019-11-28 11:37:30", "instrumented" : 8, "covered" : 0,};
var merged_data = [];
